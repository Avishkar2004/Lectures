j.s is synchoronous in nature but after the introduction of Nodejs the j.s was converted into ASYNC.
js behaves sync in the front end
js behaves async in the back end.

Async communication :-
concurrency :-
  -one after the other
  -step by step
              Eg:-
              console.log('hru')
              let a = 10;
              let b = 20;
              console.log(a+b)
              console.log(a/b)
              give the output in console 1.hru 2.30. 3.0.5 this is how it's work.
CallBack Function/Recursive Function/Iterative fucntion/Lambda Function:-
  =>it is a function which is passed as a argument function.
    
Callback chaining :- 
function a ()(function(b){
    
}){

})}

CallBack Hell :-
=>Whenever you have multiple callback it may led to call back hell.
it is a situation where the flow looks like execution in a direction that was called but infact it is opposite.
=>To overcome such as situation promise was introduce.

promise :-
=> It is method which was introduced to overcome the problem that were faced while using multiple callbacks.
=> Promise is asychronos in nature
=> Every promise has 4 stages, namely
1. Pending stage :-promise is invokes but we dont have the solution yet.
2. Rejected state :-promise is invokes but it generated a error.
3. Full-filled stage :-the promise is invokes and the
                 result is also generated / the promise is resolved.
4.settled stage :- promise which was invoked has a outcome

  1-then method
  2-catch mathod :-it is used to handle the error that is generated by the promise.

  pseudo Code :-
  promise().then().catch(f)

function abc(resolve,reject){
    it true 
       resolve()
    else
        reject()
}
xyz = new Promise.all(abc(),def(),xyz())
=> get multiple result at once = stored in a form of array.


xyz is a promise method
abc is a normal method

xyz.then(() =>{}).catch(()=>{})

Promise chaining :-(then) method is repeated

xyz
.then(() =>{})
.then(() =>{})
.then(() =>{})
.then(() =>{})
.catch(()=>{})

promise method :-
     promise.all()

     when you have multiple promises as argument to a single promise.then that single promise should be declare as promise.all()
     Eg:- xyz.then(() =>{}).catch(()=>{})

keyword
  1.-async = This is triggred the function asynchronously it will result a promise.
  2.-await = This keyword is used to make the function wait. until it receives a resolve from a promise it will wait !!!
  

  MATERIAL :-
  j.s runs on a single thread.This thread based on event.j.s function are hoisted.function declares in variables will not execute if called before being as the variable does not exist.

  2.Callback in j.s :-in j.s function are first-class citizen,you can pass a function to another function as an argument.
  def=>a callback is a function that you pass into another function as an argument for executing later.

  function filter(numbers) {
  let results = [];
  for (const number of numbers) {
    if (number % 2 != 0) {
      results.push(number);
    }
  }
  return results;
}
let numbers = [1, 2, 4, 7, 3, 5, 6];
console.log(filter(numbers));

  How it's work :-first, defines the filter() function that accepts an array of number and return a new array of the numbers.
  second, define the numbers array that has odd and even number.
  third,call the filter() function to get the odd numberout of the numbers array and output the result.
  =>first,extract the logic in the if block and wrap it in a separated function.
  =>second,pass the function to the function to the filter() function as an argumetn.

  2.Synchronous Callbacks:-a synchronous callback is execute during the execute of the high-order function that uses the callback.
  3.Asynchronous callbacks :- an asynchronous callback is execute after thr execution of the high-order function that uses the callback.
  Asynchronicity means that if j.s has to wait for an operation to complete.it will execute the rest of the code while waiting.

  3.callback hell or pyramid of doom :- nesting many asynchronous function inside callback is know as the pyramid of doom or the callback hell.

  4.Promise in j.s => promise are object that represent the eventtual outcome of an asynchronous operation.
  => ther are three stage.
  1.pending  :- the initial state - the operation has not completed yet.
  2.Fulfilled :- the operation has completed successfully and the promise now has a resolve value.
  3.Rejected :- the operation has failed and the promise has a reason for the failure .this reason is usually an Error of some kind.

  creating a promise :-
  const executorFunction = (resolve, reject) => { };
const myFirstPromise = new Promise(executorFunction);

5.consuming promises :- the initial stage of an asynchronous promise is pending, but we have a guerantee that it will settled.Promise object come with an aptly named .then() method.

then() => is a higher-oder function- it takes two callback function as argument.we refer to these callbacks as handlers.

=>The first handler :- something called onfulfilled is a success handler, and it should contain the logic for the promise resolving.
=>The second handler :- something called onRejected, is a failure handler,and it should contain the logic for the promise rejecting.

6.catch() method with promise :-Remember, .then() will return promise with the same settled values as the promise it was called on if no appropriate handler was provide.
=> .catch() function takes only one argument, onRejected.

7.Chaining multiple Promises :- This process of chaining promise togther is called composition.

firstPromiseFunction()
.then((firstResolveVal) => {
  return secondPromiseFunction(firstResolveVal);
})
.then((secondResolveVal) => {
  console.log(secondResolveVal);
});
=> we invokes a function firstPromiseFunction() which return a promise.
=> we invokes .then() with an anonymous function as the success handler.
=> inside the success handler we return a new promise the result of invoking a second function, secondPromiseFunction() with the first promise's resolved value.
=> we invokes a second .then() to handler the logic for the second promise settling.
=> inside that .then() we have success handler which will log to the second promise's resolve value to the console

8.Promise.all() method :- accepts an array of promises as it's argument and return a single promise. That single promise will settled in one of two ways :-
1.if every promise in the argument array resolve, the single promise returned from promise.all() will resolve with an array containing the resolve value from each promise in the argument array.
2.if any promise form the argument array rejects, the single promise returned from promise.all() will immediately reject with the reason that promise rejected.

The Async keyword:
The async keyword is used to write function that handel asynchronous action. We wrap our asynchronous logic inside a function prepended with the async keyword. then we invoke that function.
=> async functions always return a promise.this mean we can use traditional promise syntax, like .then() and .catch() with our asynch function. as async function will return in one of three way :-
=> if there's nothing returned from the functon, it will return a promise with a resolved value of undefined.
=> if there's a non-promise value returnedd from the function, it  will return a promise resolved to that value.
=> if a promise is return from the function, it will simply reeturn that promise.

The Await Operator:-The await keyword can only be used inside an async function. await is an operator: it return the resolve value of a promise .

8.Handling Errors : when .catch() is used with a long promise chain, there is no indication of where in the chain the error was throws.
with async..await, we use try...catch statement for error handling.by using the syntax, not only we are able to handle error in the same way we done with synchronous code.

Await Promise.all() method : another way to take advanatage of concurrency when we have multiple promises which can be execute simultaneously is to await a promise.all()
=>we can pass an array of promises as the argument to promise.all(),and it will return a single promise.

=> Interview Questions
Q1.What is your understanding of the Event Loop concept in JavaScript?

The Event Loop is a mechanism used by JavaScript to handle asynchronous events. It is a continuous loop that checks for events and then processes them accordingly. This allows JavaScript to handle multiple events at the same time and makes it possible for things like animations and user input to be processed without blocking the main thread of execution.lÌ¥
